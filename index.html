<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sprite Sheet Tool</title>
  <script type="module">
    import { removeBackground, preload } from 'https://esm.run/@imgly/background-removal@1.7.0';
    window.removeBackground = removeBackground;
    window.preloadRemoveBackground = preload;
  </script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 15px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      padding: 30px;
    }

    h1 {
      color: #333;
      margin-bottom: 30px;
      text-align: center;
    }

    .controls-section {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 10px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .control-group-row {
      display: flex;
      gap: 10px;
      align-items: flex-end;
    }

    .control-group-row .control-group {
      flex: 1;
      margin-bottom: 0;
    }

    label {
      font-weight: 600;
      color: #333;
      font-size: 14px;
    }

    input[type="number"],
    input[type="file"],
    select {
      padding: 10px;
      border: 2px solid #ddd;
      border-radius: 5px;
      font-size: 14px;
      transition: border-color 0.3s;
    }

    input[type="number"]:focus,
    input[type="file"]:focus,
    select:focus {
      outline: none;
      border-color: #667eea;
    }

    input[type="checkbox"] {
      width: 20px;
      height: 20px;
      cursor: pointer;
      accent-color: #667eea;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      background: white;
      border: 2px solid #ddd;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s;
      height: fit-content;
    }

    .checkbox-group:hover {
      border-color: #667eea;
    }

    .checkbox-group input[type="checkbox"] {
      margin: 0;
    }

    .checkbox-group label {
      margin: 0;
      cursor: pointer;
      font-size: 14px;
    }

    .background-removal-group {
      display: flex;
      align-items: flex-end;
      gap: 10px;
      padding: 10px;
      background: white;
      border: 2px solid #ddd;
      border-radius: 5px;
    }

    .background-removal-checkbox {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }

    .background-removal-checkbox input[type="checkbox"] {
      margin: 0;
    }

    .background-removal-checkbox label {
      margin: 0;
      cursor: pointer;
      font-size: 14px;
      white-space: nowrap;
    }

    .background-color-select {
      flex: 1;
      display: none;
    }

    .background-color-select.visible {
      display: block;
    }

    .drop-zone {
      border: 3px dashed #667eea;
      border-radius: 10px;
      padding: 40px;
      text-align: center;
      cursor: pointer;
      background: #f0f4ff;
      transition: all 0.3s;
      grid-column: 1 / -1;
    }

    .drop-zone:hover {
      background: #e8edff;
      border-color: #764ba2;
    }

    .drop-zone.dragover {
      background: #e8edff;
      border-color: #764ba2;
      transform: scale(1.02);
    }

    .drop-zone p {
      color: #667eea;
      font-weight: 500;
      margin-bottom: 10px;
    }

    .drop-zone small {
      display: block;
      color: #999;
      font-size: 12px;
      margin-top: 8px;
    }

    .drop-zone input[type="file"] {
      display: none;
    }

    .main-content {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin-bottom: 30px;
    }

    .preview-section {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .preview-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .preview-title {
      font-weight: 600;
      color: #333;
      font-size: 16px;
    }

    .preview-container {
      background: #1a1a1a;
      border-radius: 10px;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: 400px;
      position: relative;
      overflow: auto;
    }

    .preview-container.bg-transparent {
      background: repeating-conic-gradient(#606060 0% 25%, #808080 0% 50%) 50% / 20px 20px;
    }

    .preview-container.bg-black {
      background: #000000;
    }

    .preview-container.bg-white {
      background: #ffffff;
    }

    canvas#previewCanvas {
      image-rendering: pixelated;
      max-width: 100%;
      max-height: 100%;
    }

    .preview-container.stretch canvas#previewCanvas {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .frame-size-section {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      padding: 15px;
      background: white;
      border: 2px solid #ddd;
      border-radius: 8px;
      grid-column: 1 / -1;
    }

    .frame-size-control {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .frame-size-control label {
      font-size: 12px;
      font-weight: 600;
    }

    .frame-size-control input {
      padding: 8px;
      font-size: 13px;
    }

    .padding-controls-section {
      grid-column: 1 / -1;
      display: flex;
      flex-direction: column;
      gap: 0;
    }

    .padding-controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      padding: 15px;
      background: white;
      border: 2px solid #ddd;
      border-radius: 8px;
      padding-top: 40px;
      position: relative;
    }

    .padding-controls::before {
      content: 'Padding (from original frame size)';
      position: absolute;
      top: 8px;
      left: 15px;
      font-weight: 700;
      color: #333;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .padding-control {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .padding-control label {
      font-size: 12px;
      font-weight: 600;
    }

    .padding-control input {
      padding: 8px;
      font-size: 13px;
    }

    .slider-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: #ddd;
      outline: none;
      -webkit-appearance: none;
      cursor: pointer;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #667eea;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      background: #5568d3;
      transform: scale(1.2);
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #667eea;
      cursor: pointer;
      border: none;
      transition: all 0.2s;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }

    input[type="range"]::-moz-range-thumb:hover {
      background: #5568d3;
      transform: scale(1.2);
    }

    .slider-label {
      text-align: center;
      font-size: 12px;
      color: #666;
    }

    .info-text {
      text-align: center;
      color: #999;
      font-size: 14px;
    }

    .frames-section {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .frames-label {
      font-weight: 600;
      color: #333;
    }

    .frames-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      max-height: 500px;
      overflow-y: auto;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 10px;
      border: 2px solid #e0e0e0;
    }

    .frame-item {
      position: relative;
      cursor: pointer;
      border-radius: 8px;
      overflow: hidden;
      border: 3px solid #ddd;
      background: white;
      transition: all 0.2s;
    }

    .frame-item:hover {
      border-color: #667eea;
      transform: scale(1.05);
    }

    .frame-item.excluded {
      opacity: 0.5;
      background: #f0f0f0;
    }

    .frame-item canvas {
      width: 100%;
      height: 80px;
      display: block;
      image-rendering: pixelated;
    }

    .frame-item .frame-number {
      position: absolute;
      top: 2px;
      right: 2px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 10px;
      padding: 2px 5px;
      border-radius: 3px;
    }

    .frame-item.included {
      border-color: #28a745;
      box-shadow: 0 0 10px rgba(40, 167, 69, 0.3);
    }

    .buttons-section {
      display: flex;
      gap: 15px;
      justify-content: center;
      flex-wrap: wrap;
    }

    button {
      padding: 12px 30px;
      font-size: 14px;
      font-weight: 600;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .btn-primary {
      background: #667eea;
      color: white;
    }

    .btn-primary:hover {
      background: #5568d3;
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }

    .btn-secondary {
      background: #6c757d;
      color: white;
    }

    .btn-secondary:hover {
      background: #5a6268;
      transform: translateY(-2px);
    }

    .btn-success {
      background: #28a745;
      color: white;
    }

    .btn-success:hover {
      background: #218838;
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }

    button:disabled:hover {
      background-color: inherit;
    }

    .status-message {
      text-align: center;
      padding: 15px;
      border-radius: 8px;
      font-weight: 500;
      display: none;
    }

    .status-message.show {
      display: block;
    }

    .status-message.success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }

    .status-message.error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }

    .status-message.info {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 10px;
    }

    .stat-item {
      text-align: center;
    }

    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #667eea;
    }

    .stat-label {
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }

    .source-type-indicator {
      display: inline-block;
      padding: 4px 8px;
      background: #667eea;
      color: white;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      margin-top: 8px;
    }

    .video-element {
      display: none;
    }

    .processing-indicator {
      text-align: center;
      padding: 20px;
      background: #e3f2fd;
      border-radius: 8px;
      color: #1565c0;
      font-weight: 500;
      margin-bottom: 20px;
    }

    .progress-bar {
      width: 100%;
      height: 4px;
      background: #ddd;
      border-radius: 2px;
      overflow: hidden;
      margin-top: 8px;
    }

    .progress-fill {
      height: 100%;
      background: #667eea;
      width: 0%;
      transition: width 0.3s;
    }

    .control-group.disabled {
      opacity: 0.5;
      pointer-events: none;
    }

    .fps-controls-group {
      display: flex;
      gap: 10px;
      align-items: flex-end;
    }

    .fps-controls-group .control-group {
      flex: 1;
    }

    .bg-removal-processing {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 10px;
      z-index: 10;
      color: white;
      font-weight: 600;
    }
  </style>
</head>
<body>
<div class="container">
  <h1>üé® Sprite Sheet Tool</h1>

  <div class="controls-section">
    <div class="drop-zone" id="dropZone">
      <p>üìÅ Drop your sprite sheet or video here or click to browse</p>
      <small>Supports PNG, JPG, GIF, MP4, WebM, OGG and many more</small>
      <input type="file" id="mediaInput" accept="image/*,video/*">
    </div>

    <div class="control-group" id="rowsGroup">
      <label for="rowsInput">Rows (for preview)</label>
      <input type="number" id="rowsInput" min="1" max="100" value="1">
    </div>

    <div class="control-group" id="columnsGroup">
      <label for="columnsInput">Columns (for preview)</label>
      <input type="number" id="columnsInput" min="1" max="100" value="1">
    </div>

    <div class="fps-controls-group">
      <div class="control-group">
        <label for="animationFpsInput">Animation FPS</label>
        <input type="number" id="animationFpsInput" min="1" max="60" value="12">
      </div>
    </div>

    <div class="fps-controls-group">
      <div class="control-group">
        <label for="videoFpsInput">Video Extraction FPS</label>
        <input type="number" id="videoFpsInput" min="1" max="60" value="12">
      </div>
    </div>
	
	<div class="padding-controls-section">
      <div class="padding-controls">
        <div class="padding-control">
          <label for="paddingTopInput">Top (px)</label>
          <input type="number" id="paddingTopInput" min="0" value="0">
        </div>
        <div class="padding-control">
          <label for="paddingRightInput">Right (px)</label>
          <input type="number" id="paddingRightInput" min="0" value="0">
        </div>
        <div class="padding-control">
          <label for="paddingBottomInput">Bottom (px)</label>
          <input type="number" id="paddingBottomInput" min="0" value="0">
        </div>
        <div class="padding-control">
          <label for="paddingLeftInput">Left (px)</label>
          <input type="number" id="paddingLeftInput" min="0" value="0">
        </div>
      </div>
    </div>

    <div class="frame-size-section">
      <div class="frame-size-control">
        <label for="frameWidthInput">Frame Width (px)</label>
        <input type="number" id="frameWidthInput" min="1" value="0">
      </div>
      <div class="frame-size-control">
        <label for="frameHeightInput">Frame Height (px)</label>
        <input type="number" id="frameHeightInput" min="1" value="0">
      </div>
    </div>

    <div class="background-removal-group">
      <div class="background-removal-checkbox">
        <input type="checkbox" id="removeBackgroundCheckbox">
        <label for="removeBackgroundCheckbox">Remove Background</label>
      </div>
      <select id="backgroundColorSelect" class="background-color-select">
        <option value="transparent">Transparent</option>
        <option value="black">Black</option>
        <option value="white">White</option>
        <option value="#FF0000">Red</option>
        <option value="#00FF00">Green</option>
        <option value="#0000FF">Blue</option>
        <option value="#FFFF00">Yellow</option>
        <option value="#FF00FF">Magenta</option>
        <option value="#00FFFF">Cyan</option>
        <option value="#FFA500">Orange</option>
        <option value="#800080">Purple</option>
        <option value="#FFC0CB">Pink</option>
        <option value="#A52A2A">Brown</option>
        <option value="#808080">Gray</option>
      </select>
    </div>

    <div class="checkbox-group">
      <input type="checkbox" id="stretchCheckbox">
      <label for="stretchCheckbox">Stretch Preview (Keep Aspect Ratio)</label>
    </div>
  </div>

  <div class="status-message" id="statusMessage"></div>
  <div id="processingIndicator" class="processing-indicator" style="display: none;">
    Extracting frames from video... <span id="frameCount">0</span>/<span id="frameTotalCount">0</span>
    <div class="progress-bar">
      <div class="progress-fill" id="progressFill"></div>
    </div>
  </div>

  <div class="main-content">
    <div class="preview-section">
      <div class="preview-header">
        <div class="preview-title" id="previewTitle">Animation Preview</div>
      </div>
      <div class="preview-container" id="previewContainer">
        <canvas id="previewCanvas"></canvas>
      </div>
      <div class="slider-container">
        <input type="range" id="frameSlider" min="0" max="0" value="0">
        <div class="slider-label" id="sliderLabel">Drag to scrub through frames</div>
      </div>
      <div class="stats">
        <div class="stat-item">
          <div class="stat-value" id="totalFrames">0</div>
          <div class="stat-label">Total Frames</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="selectedFrames">0</div>
          <div class="stat-label">Selected Frames</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="animDuration">0s</div>
          <div class="stat-label">Duration</div>
        </div>
      </div>
    </div>

    <div class="frames-section">
      <label class="frames-label">Frame Selection</label>
      <div class="frames-grid" id="framesGrid"></div>
      <div class="buttons-section" style="flex-direction: column; gap: 10px; margin-top: 15px;">
        <button class="btn-secondary" id="selectAllBtn">Select All</button>
        <button class="btn-secondary" id="deselectAllBtn">Deselect All</button>
      </div>
    </div>
  </div>

  <div class="buttons-section" style="margin-top: 30px; border-top: 2px solid #e0e0e0; padding-top: 30px;">
    <button class="btn-success" id="exportBtn" disabled>üì• Export Selected Sprites</button>
  </div>
</div>

<video id="videoElement" class="video-element"></video>

<script>
  class SpriteSheetEditor {
    constructor() {
      this.media = null;
      this.mediaType = null;
      this.rows = 1;
      this.columns = 1;
      this.animationFps = 12;
      this.videoFps = 12;
      this.frameWidth = 0;
      this.frameHeight = 0;
      this.displayFrameWidth = 0;
      this.displayFrameHeight = 0;
      this.paddingTop = 0;
      this.paddingRight = 0;
      this.paddingBottom = 0;
      this.paddingLeft = 0;
      this.selectedFrames = new Set();
      this.currentFrame = 0;
      this.lastFrameTime = 0;
      this.animationRunning = false;
      this.frames = [];
      this.isSliderDragging = false;
      this.stretchPreview = false;
      this.needsRender = false;
      this.lastRenderedFrame = -1;
      this.removeBackground = false;
      this.backgroundColor = 'transparent';
      this.processedFrames = new Map();
      this.isProcessingBackground = false;
	  this.removeBackgroundConfig = {
		device: this.isSecureOrLocalhost() ? "gpu" : "cpu", 
		proxyToWorker: true,
	  };
	  this.removeBackgroundModelInitialized = false;

      this.initializeElements();
      this.attachEventListeners();
      this.updateFrameSizeInputs();
      this.startAnimationLoop();
	  
	  if (typeof window.removeBackground === 'undefined') {
        console.warn('Background removal library not yet loaded. It will be available after a moment.');
        // Wait for library to load
		
		            console.error('Background removal library failed to load');

        setTimeout(() => {
          if (typeof window.removeBackground === 'undefined') {
            console.error('Background removal library failed to load');
          } else {
			this.preloadBackgroundRemovalModel();
		  }
        }, 3000);
      } else {
		this.preloadBackgroundRemovalModel();
	  }
    }
	
	async preloadBackgroundRemovalModel() {
		console.log('initializing background removal model...');
		await window.preloadRemoveBackground(this.removeBackgroundConfig);
		console.log('Background removal model initialized');
		this.removeBackgroundModelInitialized = true;
	}

    initializeElements() {
      this.dropZone = document.getElementById('dropZone');
      this.mediaInput = document.getElementById('mediaInput');
      this.rowsInput = document.getElementById('rowsInput');
      this.columnsInput = document.getElementById('columnsInput');
      this.animationFpsInput = document.getElementById('animationFpsInput');
      this.videoFpsInput = document.getElementById('videoFpsInput');
      this.frameWidthInput = document.getElementById('frameWidthInput');
      this.frameHeightInput = document.getElementById('frameHeightInput');
      this.paddingTopInput = document.getElementById('paddingTopInput');
      this.paddingRightInput = document.getElementById('paddingRightInput');
      this.paddingBottomInput = document.getElementById('paddingBottomInput');
      this.paddingLeftInput = document.getElementById('paddingLeftInput');
      this.stretchCheckbox = document.getElementById('stretchCheckbox');
      this.removeBackgroundCheckbox = document.getElementById('removeBackgroundCheckbox');
      this.backgroundColorSelect = document.getElementById('backgroundColorSelect');
      this.previewCanvas = document.getElementById('previewCanvas');
      this.previewCtx = this.previewCanvas.getContext('2d');
      this.previewContainer = document.getElementById('previewContainer');
      this.frameSlider = document.getElementById('frameSlider');
      this.sliderLabel = document.getElementById('sliderLabel');
      this.previewTitle = document.getElementById('previewTitle');
      this.framesGrid = document.getElementById('framesGrid');
      this.exportBtn = document.getElementById('exportBtn');
      this.selectAllBtn = document.getElementById('selectAllBtn');
      this.deselectAllBtn = document.getElementById('deselectAllBtn');
      this.statusMessage = document.getElementById('statusMessage');
      this.totalFramesDisplay = document.getElementById('totalFrames');
      this.selectedFramesDisplay = document.getElementById('selectedFrames');
      this.animDurationDisplay = document.getElementById('animDuration');
      this.videoElement = document.getElementById('videoElement');
      this.processingIndicator = document.getElementById('processingIndicator');
      this.progressFill = document.getElementById('progressFill');
      this.frameCountDisplay = document.getElementById('frameCount');
      this.frameTotalCountDisplay = document.getElementById('frameTotalCount');
      this.rowsGroup = document.getElementById('rowsGroup');
      this.columnsGroup = document.getElementById('columnsGroup');
    }

    attachEventListeners() {
      // Drop zone events
      this.dropZone.addEventListener('click', () => this.mediaInput.click());
      this.dropZone.addEventListener('dragover', (e) => this.handleDragOver(e));
      this.dropZone.addEventListener('dragleave', (e) => this.handleDragLeave(e));
      this.dropZone.addEventListener('drop', (e) => this.handleDrop(e));

      // File input
      this.mediaInput.addEventListener('change', (e) => this.handleMediaUpload(e));

      // Control inputs
      this.rowsInput.addEventListener('change', () => this.updateGrid());
      this.columnsInput.addEventListener('change', () => this.updateGrid());

      this.animationFpsInput.addEventListener('change', () => {
        this.animationFps = parseInt(this.animationFpsInput.value) || 12;
        this.updateStats();
      });

      this.videoFpsInput.addEventListener('change', () => {
        this.videoFps = parseInt(this.videoFpsInput.value) || 12;
        if (this.mediaType === 'video') {
          this.extractVideoFrames();
        }
      });

      // Frame size inputs
      this.frameWidthInput.addEventListener('change', () => this.updateFrameSize());
      this.frameHeightInput.addEventListener('change', () => this.updateFrameSize());

      // Padding inputs
      this.paddingTopInput.addEventListener('change', () => this.updatePadding());
      this.paddingRightInput.addEventListener('change', () => this.updatePadding());
      this.paddingBottomInput.addEventListener('change', () => this.updatePadding());
      this.paddingLeftInput.addEventListener('change', () => this.updatePadding());

      // Stretch checkbox
      this.stretchCheckbox.addEventListener('change', () => this.updateStretchPreview());

      // Background removal controls
      this.removeBackgroundCheckbox.addEventListener('change', () => this.toggleBackgroundRemoval());
      this.backgroundColorSelect.addEventListener('change', () => this.updateBackgroundColor());

      // Frame slider
      this.frameSlider.addEventListener('mousedown', () => this.onSliderDragStart());
      this.frameSlider.addEventListener('touchstart', () => this.onSliderDragStart());
      this.frameSlider.addEventListener('input', (e) => this.onSliderInput(e));
      this.frameSlider.addEventListener('mouseup', () => this.onSliderDragEnd());
      this.frameSlider.addEventListener('touchend', () => this.onSliderDragEnd());

      // Button events
      this.selectAllBtn.addEventListener('click', () => this.selectAll());
      this.deselectAllBtn.addEventListener('click', () => this.deselectAll());
      this.exportBtn.addEventListener('click', () => this.exportSprites());

      // Video element event
      this.videoElement.addEventListener('loadedmetadata', () => this.onVideoLoaded());
    }

    toggleBackgroundRemoval() {
      this.removeBackground = this.removeBackgroundCheckbox.checked;
      this.backgroundColorSelect.classList.toggle('visible', this.removeBackground);
      
      if (this.removeBackground) {
        this.processedFrames.clear();
        this.processAllFramesBackground();
      } else {
        this.processedFrames.clear();
      }
	  this.updatePreviewBackgroundColor();
    }

    updateBackgroundColor() {
      this.backgroundColor = this.backgroundColorSelect.value;
      this.updatePreviewBackgroundColor();
      this.needsRender = true;
    }

    updatePreviewBackgroundColor() {
      if (!this.removeBackground) {
        this.previewContainer.classList.remove('bg-transparent', 'bg-black', 'bg-white');
        return;
      }

      this.previewContainer.classList.remove('bg-transparent', 'bg-black', 'bg-white');
      
      if (this.backgroundColor === 'transparent') {
        this.previewContainer.classList.add('bg-transparent');
      } else if (this.backgroundColor === 'black') {
        this.previewContainer.classList.add('bg-black');
      } else if (this.backgroundColor === 'white') {
        this.previewContainer.classList.add('bg-white');
      } else {
        this.previewContainer.style.background = this.backgroundColor;
      }
    }

    async processAllFramesBackground() {
      if (this.frames.length === 0 && this.mediaType !== 'image') return;

      this.isProcessingBackground = true;
      const totalFrames = this.mediaType === 'video' ? this.frames.length : (this.rows * this.columns);
      
      for (let i = 0; i < totalFrames; i++) {
        if (this.processedFrames.has(i)) continue;
        await this.processFrameBackground(i);
      }

      this.isProcessingBackground = false;
      this.renderFrameGrid();
      this.needsRender = true;
    }

    async processFrameBackground(frameIndex) {
      try {
        let canvas = document.createElement('canvas');
        
        if (this.mediaType === 'image') {
          canvas.width = this.frameWidth;
          canvas.height = this.frameHeight;
          const ctx = canvas.getContext('2d');
          
          const row = Math.floor(frameIndex / this.columns);
          const col = frameIndex % this.columns;
          
          ctx.drawImage(
            this.media,
            col * this.frameWidth,
            row * this.frameHeight,
            this.frameWidth,
            this.frameHeight,
            0,
            0,
            this.frameWidth,
            this.frameHeight
          );
        } else if (this.mediaType === 'video') {
          const frameData = this.frames[frameIndex];
          const img = new Image();
          
          await new Promise((resolve) => {
            img.onload = () => {
              canvas.width = this.frameWidth;
              canvas.height = this.frameHeight;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0, this.frameWidth, this.frameHeight);
              resolve();
            };
            img.src = frameData;
          });
        }

        // Convert canvas to blob for processing
        const blob = await this.canvasToBlob(canvas);
        
        // Use the global removeBackground function from the library
		
        const result = await window.removeBackground(blob, this.removeBackgroundConfig);
        this.processedFrames.set(frameIndex, result);
      } catch (error) {
        console.error(`Error processing frame ${frameIndex}:`, error);
        this.showMessage(`Error processing frame ${frameIndex}`, 'error');
      }
    }
	
	isSecureOrLocalhost() {
	  const protocol = window.location.protocol;
	  const hostname = window.location.hostname;
	  
	  return protocol === "https:" || hostname === "localhost" || hostname === "127.0.0.1";
	}

    canvasToBlob(canvas) {
      return new Promise((resolve) => {
        canvas.toBlob(resolve);
      });
    }

    async getProcessedFrameCanvas(frameIndex) {
      if (!this.removeBackground || !this.processedFrames.has(frameIndex)) {
        return null;
      }

      const blob = this.processedFrames.get(frameIndex);
      const url = URL.createObjectURL(blob);
      
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          canvas.width = this.displayFrameWidth;
          canvas.height = this.displayFrameHeight;
          const ctx = canvas.getContext('2d');
          
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          if (this.backgroundColor !== 'transparent') {
            if (this.backgroundColor === 'black') {
              ctx.fillStyle = '#000000';
            } else if (this.backgroundColor === 'white') {
              ctx.fillStyle = '#ffffff';
            } else {
              ctx.fillStyle = this.backgroundColor;
            }
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }
          
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          URL.revokeObjectURL(url);
          resolve(canvas);
        };
        img.src = url;
      });
    }

    handleDragOver(e) {
      e.preventDefault();
      this.dropZone.classList.add('dragover');
    }

    handleDragLeave(e) {
      e.preventDefault();
      this.dropZone.classList.remove('dragover');
    }

    handleDrop(e) {
      e.preventDefault();
      this.dropZone.classList.remove('dragover');

      const files = e.dataTransfer.files;
      if (files.length > 0) {
        this.mediaInput.files = files;
        this.handleMediaUpload({ target: { files } });
      }
    }

    handleMediaUpload(e) {
      const files = e.target.files;
      if (files.length === 0) return;

      const file = files[0];
      const isVideo = file.type.startsWith('video/');

      if (isVideo) {
        this.handleVideoUpload(file);
      } else {
        this.handleImageUpload(file);
      }
    }

    handleImageUpload(file) {
      const reader = new FileReader();

      reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
          this.media = img;
          this.mediaType = 'image';
          this.frames = [];
          this.processedFrames.clear();
          this.removeBackgroundCheckbox.checked = false;
          this.removeBackground = false;
          this.backgroundColorSelect.classList.remove('visible');
          this.analyzeImage();
          this.updateGridVisibility();
          this.updateFrameSizeInputs();
          this.updateGrid();
          this.showMessage('Image loaded successfully!', 'success');
        };
        img.onerror = () => {
          this.showMessage('Failed to load image', 'error');
        };
        img.src = event.target.result;
      };

      reader.readAsDataURL(file);
    }

    handleVideoUpload(file) {
      const fileURL = URL.createObjectURL(file);
      this.videoElement.src = fileURL;
      this.mediaType = 'video';
      this.media = null;
      this.frames = [];
      this.processedFrames.clear();
      this.removeBackgroundCheckbox.checked = false;
      this.removeBackground = false;
      this.backgroundColorSelect.classList.remove('visible');
      this.updateGridVisibility();
    }

    onVideoLoaded() {
      this.showMessage('Video loaded. Extracting frames...', 'info');
      this.extractVideoFrames();
    }

    extractVideoFrames() {
      const fps = parseInt(this.videoFpsInput.value) || 12;
      const videoDuration = this.videoElement.duration;
      const frameTimestamps = [];

      const frameInterval = 1 / fps;
      for (let time = 0; time < videoDuration; time += frameInterval) {
        frameTimestamps.push(time);
      }

      const totalFramesToExtract = frameTimestamps.length;
      this.frameTotalCountDisplay.textContent = totalFramesToExtract;
      this.processingIndicator.style.display = 'block';

      const extractedFrames = [];
      let framesProcessed = 0;

      const extractNextFrame = (index) => {
        if (index >= frameTimestamps.length) {
          this.frames = extractedFrames;
          this.processingIndicator.style.display = 'none';
          this.frameWidth = this.videoElement.videoWidth;
          this.frameHeight = this.videoElement.videoHeight;
          this.displayFrameWidth = this.frameWidth;
          this.displayFrameHeight = this.frameHeight;
          this.rows = 1;
          this.columns = 1;
          this.rowsInput.value = 1;
          this.columnsInput.value = 1;
          this.selectedFrames.clear();
          this.selectAll();
          this.updateFrameSizeInputs();
          this.renderFrameGrid();
          this.updateSlider();
          this.updateStats();
          this.startAnimation();
          this.showMessage(`Successfully extracted ${this.frames.length} frames from video!`, 'success');
          return;
        }

        const timestamp = frameTimestamps[index];
        this.videoElement.currentTime = timestamp;

        const onSeeked = () => {
          const canvas = document.createElement('canvas');
          canvas.width = this.videoElement.videoWidth;
          canvas.height = this.videoElement.videoHeight;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(this.videoElement, 0, 0);

          const imageData = canvas.toDataURL('image/png');
          extractedFrames.push(imageData);

          framesProcessed++;
          this.frameCountDisplay.textContent = framesProcessed;
          this.progressFill.style.width = (framesProcessed / totalFramesToExtract) * 100 + '%';

          this.videoElement.removeEventListener('seeked', onSeeked);
          extractNextFrame(index + 1);
        };

        this.videoElement.addEventListener('seeked', onSeeked, { once: true });
      };

      extractNextFrame(0);
    }

    analyzeImage() {
      if (!this.media || this.mediaType !== 'image') return;

      const width = this.media.width;
      const height = this.media.height;

      let bestRows = 1;
      let bestCols = 1;
      let minDifference = Infinity;

      for (let rows = 1; rows <= 10; rows++) {
        for (let cols = 1; cols <= 10; cols++) {
          if (width % cols === 0 && height % rows === 0) {
            const frameWidth = width / cols;
            const frameHeight = height / rows;
            const diff = Math.abs(frameWidth - frameHeight);

            if (diff < minDifference) {
              minDifference = diff;
              bestRows = rows;
              bestCols = cols;
            }
          }
        }
      }

      this.rowsInput.value = bestRows;
      this.columnsInput.value = bestCols;
      this.frameWidth = width / bestCols;
      this.frameHeight = height / bestRows;
      this.displayFrameWidth = this.frameWidth;
      this.displayFrameHeight = this.frameHeight;
    }

    updateGridVisibility() {
      if (this.mediaType === 'video') {
        this.rowsGroup.classList.add('disabled');
        this.columnsGroup.classList.add('disabled');
      } else {
        this.rowsGroup.classList.remove('disabled');
        this.columnsGroup.classList.remove('disabled');
      }
    }

    updateFrameSizeInputs() {
      if (this.mediaType === 'image') {
        const width = this.media.width;
        const height = this.media.height;
        this.rows = parseInt(this.rowsInput.value);
        this.columns = parseInt(this.columnsInput.value);
        this.frameWidth = width / this.columns;
        this.frameHeight = height / this.rows;
      } else if (this.mediaType === 'video' && this.frameWidth > 0) {
        // Already set
      }

      this.displayFrameWidth = this.frameWidth;
      this.displayFrameHeight = this.frameHeight;
      this.frameWidthInput.value = Math.round(this.displayFrameWidth);
      this.frameHeightInput.value = Math.round(this.displayFrameHeight);
    }

    updateFrameSize() {
      const newWidth = parseInt(this.frameWidthInput.value) || this.frameWidth;
      const newHeight = parseInt(this.frameHeightInput.value) || this.frameHeight;

      this.displayFrameWidth = newWidth;
      this.displayFrameHeight = newHeight;

      this.renderFrameGrid();
      this.updateStats();
      this.needsRender = true;
    }

    updatePadding() {
      this.paddingTop = parseInt(this.paddingTopInput.value) || 0;
      this.paddingRight = parseInt(this.paddingRightInput.value) || 0;
      this.paddingBottom = parseInt(this.paddingBottomInput.value) || 0;
      this.paddingLeft = parseInt(this.paddingLeftInput.value) || 0;

      this.renderFrameGrid();
      this.needsRender = true;
    }

    updateStretchPreview() {
      this.stretchPreview = this.stretchCheckbox.checked;
      if (this.stretchPreview) {
        this.previewContainer.classList.add('stretch');
      } else {
        this.previewContainer.classList.remove('stretch');
      }
    }

    updateGrid() {
      if (!this.media && this.mediaType !== 'video') {
        this.showMessage('Please upload media first', 'error');
        return;
      }

      if (this.mediaType === 'image') {
        this.rows = parseInt(this.rowsInput.value);
        this.columns = parseInt(this.columnsInput.value);
        this.frameWidth = this.media.width / this.columns;
        this.frameHeight = this.media.height / this.rows;
        this.displayFrameWidth = this.frameWidth;
        this.displayFrameHeight = this.frameHeight;
        this.frameWidthInput.value = Math.round(this.displayFrameWidth);
        this.frameHeightInput.value = Math.round(this.displayFrameHeight);

        this.selectedFrames.clear();
        this.selectAll();
        this.renderFrameGrid();
        this.updateSlider();
        this.updateStats();
        this.startAnimation();
      }
    }

    renderFrameGrid() {
      this.framesGrid.innerHTML = '';

      if (this.mediaType === 'image') {
        this.renderImageFrameGrid();
      } else if (this.mediaType === 'video') {
        this.renderVideoFrameGrid();
      }
    }

    renderImageFrameGrid() {
      const totalFrames = this.rows * this.columns;

      for (let i = 0; i < totalFrames; i++) {
        const frameDiv = document.createElement('div');
        frameDiv.className = 'frame-item included';
        frameDiv.dataset.frameIndex = i;

        const frameCanvas = document.createElement('canvas');
        const totalWidth = this.displayFrameWidth + this.paddingLeft + this.paddingRight;
        const totalHeight = this.displayFrameHeight + this.paddingTop + this.paddingBottom;
        frameCanvas.width = totalWidth;
        frameCanvas.height = totalHeight;
        const ctx = frameCanvas.getContext('2d');

        ctx.clearRect(0, 0, totalWidth, totalHeight);

        const row = Math.floor(i / this.columns);
        const col = i % this.columns;

        if (this.removeBackground && this.processedFrames.has(i)) {
          const processedBlob = this.processedFrames.get(i);
          const url = URL.createObjectURL(processedBlob);
          const img = new Image();
          img.onload = () => {
            if (this.backgroundColor !== 'transparent') {
              if (this.backgroundColor === 'black') {
                ctx.fillStyle = '#000000';
              } else if (this.backgroundColor === 'white') {
                ctx.fillStyle = '#ffffff';
              } else {
                ctx.fillStyle = this.backgroundColor;
              }
              ctx.fillRect(0, 0, totalWidth, totalHeight);
            }
            ctx.drawImage(
              img,
              0,
              0,
              this.displayFrameWidth,
              this.displayFrameHeight,
              this.paddingLeft,
              this.paddingTop,
              this.displayFrameWidth,
              this.displayFrameHeight
            );
            URL.revokeObjectURL(url);
          };
          img.src = url;
        } else {
          ctx.drawImage(
            this.media,
            col * this.frameWidth,
            row * this.frameHeight,
            this.frameWidth,
            this.frameHeight,
            this.paddingLeft,
            this.paddingTop,
            this.displayFrameWidth,
            this.displayFrameHeight
          );
        }

        const frameNumber = document.createElement('div');
        frameNumber.className = 'frame-number';
        frameNumber.textContent = i + 1;

        frameDiv.appendChild(frameCanvas);
        frameDiv.appendChild(frameNumber);
        frameDiv.addEventListener('click', () => this.toggleFrame(i, frameDiv));

        this.framesGrid.appendChild(frameDiv);
      }
    }

    renderVideoFrameGrid() {
      this.frames.forEach((frameData, i) => {
        const frameDiv = document.createElement('div');
        frameDiv.className = 'frame-item included';
        frameDiv.dataset.frameIndex = i;

        const frameCanvas = document.createElement('canvas');
        const totalWidth = this.displayFrameWidth + this.paddingLeft + this.paddingRight;
        const totalHeight = this.displayFrameHeight + this.paddingTop + this.paddingBottom;
        frameCanvas.width = totalWidth;
        frameCanvas.height = totalHeight;
        const ctx = frameCanvas.getContext('2d');

        ctx.clearRect(0, 0, totalWidth, totalHeight);

        if (this.removeBackground && this.processedFrames.has(i)) {
          const processedBlob = this.processedFrames.get(i);
          const url = URL.createObjectURL(processedBlob);
          const img = new Image();
          img.onload = () => {
            if (this.backgroundColor !== 'transparent') {
              if (this.backgroundColor === 'black') {
                ctx.fillStyle = '#000000';
              } else if (this.backgroundColor === 'white') {
                ctx.fillStyle = '#ffffff';
              } else {
                ctx.fillStyle = this.backgroundColor;
              }
              ctx.fillRect(0, 0, totalWidth, totalHeight);
            }
            ctx.drawImage(
              img,
              0,
              0,
              this.displayFrameWidth,
              this.displayFrameHeight,
              this.paddingLeft,
              this.paddingTop,
              this.displayFrameWidth,
              this.displayFrameHeight
            );
            URL.revokeObjectURL(url);
          };
          img.src = url;
        } else {
          const img = new Image();
          img.onload = () => {
            ctx.drawImage(
              img,
              0,
              0,
              this.frameWidth,
              this.frameHeight,
              this.paddingLeft,
              this.paddingTop,
              this.displayFrameWidth,
              this.displayFrameHeight
            );
          };
          img.src = frameData;
        }

        const frameNumber = document.createElement('div');
        frameNumber.className = 'frame-number';
        frameNumber.textContent = i + 1;

        frameDiv.appendChild(frameCanvas);
        frameDiv.appendChild(frameNumber);
        frameDiv.addEventListener('click', () => this.toggleFrame(i, frameDiv));

        this.framesGrid.appendChild(frameDiv);
      });
    }

    toggleFrame(frameIndex, frameDiv) {
      if (this.selectedFrames.has(frameIndex)) {
        this.selectedFrames.delete(frameIndex);
        frameDiv.classList.remove('included');
        frameDiv.classList.add('excluded');
      } else {
        this.selectedFrames.add(frameIndex);
        frameDiv.classList.add('included');
        frameDiv.classList.remove('excluded');
      }
      this.updateStats();
      this.updateSlider();
    }

    selectAll() {
      const totalFrames = this.mediaType === 'video' ? this.frames.length : (this.rows * this.columns);
      this.selectedFrames.clear();
      for (let i = 0; i < totalFrames; i++) {
        this.selectedFrames.add(i);
      }
      this.updateFrameVisuals();
      this.updateStats();
      this.updateSlider();
    }

    deselectAll() {
      this.selectedFrames.clear();
      this.updateFrameVisuals();
      this.updateStats();
      this.updateSlider();
    }

    updateFrameVisuals() {
      const frameItems = this.framesGrid.querySelectorAll('.frame-item');
      frameItems.forEach((item, index) => {
        if (this.selectedFrames.has(index)) {
          item.classList.add('included');
          item.classList.remove('excluded');
        } else {
          item.classList.remove('included');
          item.classList.add('excluded');
        }
      });
    }

    updateSlider() {
      const selectedArray = Array.from(this.selectedFrames).sort((a, b) => a - b);
      this.frameSlider.max = selectedArray.length;
      this.frameSlider.value = 0;
      this.lastRenderedFrame = -1;
    }

    updateStats() {
      const totalFrames = this.mediaType === 'video' ? this.frames.length : (this.rows * this.columns);
      const selectedCount = this.selectedFrames.size;
      const fps = this.animationFps;
      const duration = selectedCount > 0 ? (selectedCount / fps).toFixed(2) : 0;

      this.totalFramesDisplay.textContent = totalFrames;
      this.selectedFramesDisplay.textContent = selectedCount;
      this.animDurationDisplay.textContent = duration + 's';

      this.exportBtn.disabled = selectedCount === 0;
    }

    updatePreviewTitle() {
      const selectedArray = Array.from(this.selectedFrames).sort((a, b) => a - b);

      if (selectedArray.length === 0) {
        this.previewTitle.textContent = 'Animation Preview';
        return;
      }

      const frameIndex = selectedArray[this.currentFrame];
      const selectionIndex = this.currentFrame + 1;
      this.previewTitle.textContent = `Animation Preview - Frame ${selectionIndex}/${selectedArray.length} (Frame selection: ${frameIndex + 1})`;
    }

    onSliderDragStart() {
      this.isSliderDragging = true;
      this.animationRunning = false;
    }

    onSliderInput(e) {
      const selectedArray = Array.from(this.selectedFrames).sort((a, b) => a - b);
      const sliderValue = parseInt(this.frameSlider.value);

      if (selectedArray.length === 0) return;

      if (sliderValue >= selectedArray.length) {
        this.currentFrame = 0;
      } else {
        this.currentFrame = sliderValue;
      }

      this.updatePreviewTitle();
      this.needsRender = true;
    }

    onSliderDragEnd() {
      this.isSliderDragging = false;
      this.startAnimation();
    }

    startAnimation() {
      if (this.isSliderDragging) return;
      this.animationRunning = true;
      this.lastFrameTime = Date.now();
      this.currentFrame = 0;
      this.lastRenderedFrame = -1;
    }

    startAnimationLoop() {
      setInterval(() => {
        // Handle slider dragging render
        if (this.needsRender) {
          const selectedArray = Array.from(this.selectedFrames).sort((a, b) => a - b);
          if (selectedArray.length > 0) {
            this.renderPreview(selectedArray);
          }
          this.needsRender = false;
          return;
        }

        // Handle animation rendering
        if (!this.animationRunning || this.isSliderDragging) return;

        const now = Date.now();
        const elapsed = (now - this.lastFrameTime) / 1000;
        const frameTime = 1 / this.animationFps;

        if (elapsed >= frameTime) {
          this.currentFrame++;
          const selectedArray = Array.from(this.selectedFrames).sort((a, b) => a - b);

          if (selectedArray.length === 0) {
            this.animationRunning = false;
            return;
          }

          if (this.currentFrame >= selectedArray.length) {
            this.currentFrame = 0;
          }

          if (this.lastRenderedFrame !== this.currentFrame) {
            this.lastRenderedFrame = this.currentFrame;
            this.updatePreviewTitle();
            this.renderPreview(selectedArray);
            this.frameSlider.value = this.currentFrame;
          }

          this.lastFrameTime = now;
        }
      }, 16);
    }

    async renderPreview(selectedFrames = null) {
      if (!selectedFrames) {
        selectedFrames = Array.from(this.selectedFrames).sort((a, b) => a - b);
      }

      if ((this.mediaType === 'image' && !this.media) || (this.mediaType === 'video' && this.frames.length === 0) || selectedFrames.length === 0) {
        this.previewCanvas.width = 200;
        this.previewCanvas.height = 200;
        this.previewCtx.fillStyle = '#333';
        this.previewCtx.fillRect(0, 0, 200, 200);
        return;
      }

      const frameIndex = selectedFrames[this.currentFrame];
      const totalWidth = this.displayFrameWidth + this.paddingLeft + this.paddingRight;
      const totalHeight = this.displayFrameHeight + this.paddingTop + this.paddingBottom;

      this.previewCanvas.width = totalWidth;
      this.previewCanvas.height = totalHeight;
      this.previewCtx.clearRect(0, 0, totalWidth, totalHeight);

      if (this.removeBackground && this.processedFrames.has(frameIndex)) {
        const processedCanvas = await this.getProcessedFrameCanvas(frameIndex);
        if (processedCanvas) {
          if (this.backgroundColor !== 'transparent') {
            if (this.backgroundColor === 'black') {
              this.previewCtx.fillStyle = '#000000';
            } else if (this.backgroundColor === 'white') {
              this.previewCtx.fillStyle = '#ffffff';
            } else {
              this.previewCtx.fillStyle = this.backgroundColor;
            }
            this.previewCtx.fillRect(0, 0, totalWidth, totalHeight);
          }
          this.previewCtx.drawImage(processedCanvas, this.paddingLeft, this.paddingTop);
          return;
        }
      }

      if (this.mediaType === 'image') {
        const row = Math.floor(frameIndex / this.columns);
        const col = frameIndex % this.columns;

        this.previewCtx.drawImage(
          this.media,
          col * this.frameWidth,
          row * this.frameHeight,
          this.frameWidth,
          this.frameHeight,
          this.paddingLeft,
          this.paddingTop,
          this.displayFrameWidth,
          this.displayFrameHeight
        );
      } else if (this.mediaType === 'video') {
        const frameData = this.frames[frameIndex];
        const img = new Image();
        img.onload = () => {
          this.previewCtx.drawImage(
            img,
            0,
            0,
            this.frameWidth,
            this.frameHeight,
            this.paddingLeft,
            this.paddingTop,
            this.displayFrameWidth,
            this.displayFrameHeight
          );
        };
        img.src = frameData;
      }
    }

    calculateOptimalGrid(frameCount) {
      const squareRoot = Math.sqrt(frameCount);
      return { rows: Math.floor(squareRoot), cols: Math.ceil(squareRoot) };
    }

    exportSprites() {
      if (this.selectedFrames.size === 0) {
        this.showMessage('Please select at least one frame to export', 'error');
        return;
      }

      const selectedArray = Array.from(this.selectedFrames).sort((a, b) => a - b);
      const optimalGrid = this.calculateOptimalGrid(selectedArray.length);
      const exportRows = optimalGrid.rows;
      const exportCols = optimalGrid.cols;

      const totalWidth = this.displayFrameWidth + this.paddingLeft + this.paddingRight;
      const totalHeight = this.displayFrameHeight + this.paddingTop + this.paddingBottom;

      const exportCanvas = document.createElement('canvas');
      const exportCtx = exportCanvas.getContext('2d');
      exportCanvas.width = totalWidth * exportCols;
      exportCanvas.height = totalHeight * exportRows;

      if (this.mediaType === 'image') {
        this.exportImageSprites(exportCanvas, exportCtx, selectedArray, exportRows, exportCols, totalWidth, totalHeight);
      } else if (this.mediaType === 'video') {
        this.exportVideoSprites(exportCanvas, exportCtx, selectedArray, exportRows, exportCols, totalWidth, totalHeight);
      }
    }

    exportImageSprites(exportCanvas, exportCtx, selectedArray, exportRows, exportCols, totalWidth, totalHeight) {
      let processedCount = 0;
      const totalToProcess = selectedArray.length;

      selectedArray.forEach((frameIndex, index) => {
        const row = Math.floor(frameIndex / this.columns);
        const col = frameIndex % this.columns;

        const exportRow = Math.floor(index / exportCols);
        const exportCol = index % exportCols;

        if (this.removeBackground && this.processedFrames.has(frameIndex)) {
          const processedBlob = this.processedFrames.get(frameIndex);
          const url = URL.createObjectURL(processedBlob);
          const img = new Image();
          img.onload = () => {
            if (this.backgroundColor !== 'transparent') {
              if (this.backgroundColor === 'black') {
                exportCtx.fillStyle = '#000000';
              } else if (this.backgroundColor === 'white') {
                exportCtx.fillStyle = '#ffffff';
              } else {
                exportCtx.fillStyle = this.backgroundColor;
              }
              exportCtx.fillRect(
                exportCol * totalWidth,
                exportRow * totalHeight,
                totalWidth,
                totalHeight
              );
            }
            exportCtx.drawImage(
              img,
              0,
              0,
              this.displayFrameWidth,
              this.displayFrameHeight,
              exportCol * totalWidth + this.paddingLeft,
              exportRow * totalHeight + this.paddingTop,
              this.displayFrameWidth,
              this.displayFrameHeight
            );
            URL.revokeObjectURL(url);
            processedCount++;
            if (processedCount === totalToProcess) {
              this.downloadCanvas(exportCanvas, exportRows, exportCols);
            }
          };
          img.src = url;
        } else {
          exportCtx.drawImage(
            this.media,
            col * this.frameWidth,
            row * this.frameHeight,
            this.frameWidth,
            this.frameHeight,
            exportCol * totalWidth + this.paddingLeft,
            exportRow * totalHeight + this.paddingTop,
            this.displayFrameWidth,
            this.displayFrameHeight
          );
          processedCount++;
          if (processedCount === totalToProcess) {
            this.downloadCanvas(exportCanvas, exportRows, exportCols);
          }
        }
      });
    }

    exportVideoSprites(exportCanvas, exportCtx, selectedArray, exportRows, exportCols, totalWidth, totalHeight) {
      let loadedImages = 0;
      const totalImages = selectedArray.length;

      selectedArray.forEach((frameIndex, index) => {
        const frameData = this.frames[frameIndex];
        const img = new Image();

        img.onload = () => {
          const exportRow = Math.floor(index / exportCols);
          const exportCol = index % exportCols;

          if (this.removeBackground && this.processedFrames.has(frameIndex)) {
            const processedBlob = this.processedFrames.get(frameIndex);
            const url = URL.createObjectURL(processedBlob);
            const processedImg = new Image();
            processedImg.onload = () => {
              if (this.backgroundColor !== 'transparent') {
                if (this.backgroundColor === 'black') {
                  exportCtx.fillStyle = '#000000';
                } else if (this.backgroundColor === 'white') {
                  exportCtx.fillStyle = '#ffffff';
                } else {
                  exportCtx.fillStyle = this.backgroundColor;
                }
                exportCtx.fillRect(
                  exportCol * totalWidth,
                  exportRow * totalHeight,
                  totalWidth,
                  totalHeight
                );
              }
              exportCtx.drawImage(
                processedImg,
                0,
                0,
                this.displayFrameWidth,
                this.displayFrameHeight,
                exportCol * totalWidth + this.paddingLeft,
                exportRow * totalHeight + this.paddingTop,
                this.displayFrameWidth,
                this.displayFrameHeight
              );
              URL.revokeObjectURL(url);
              loadedImages++;
              if (loadedImages === totalImages) {
                this.downloadCanvas(exportCanvas, exportRows, exportCols);
              }
            };
            processedImg.src = url;
          } else {
            exportCtx.drawImage(
              img,
              0,
              0,
              this.frameWidth,
              this.frameHeight,
              exportCol * totalWidth + this.paddingLeft,
              exportRow * totalHeight + this.paddingTop,
              this.displayFrameWidth,
              this.displayFrameHeight
            );
            loadedImages++;
            if (loadedImages === totalImages) {
              this.downloadCanvas(exportCanvas, exportRows, exportCols);
            }
          }
        };

        img.src = frameData;
      });
    }

    downloadCanvas(canvas, rows, cols) {
      canvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `exported-sprites-${rows}x${cols}.png`;
        link.click();
        URL.revokeObjectURL(url);
        this.showMessage(`Sprites exported successfully as ${rows}x${cols} grid!`, 'success');
      });
    }

    showMessage(text, type) {
      this.statusMessage.textContent = text;
      this.statusMessage.className = `status-message show ${type}`;
      setTimeout(() => {
        this.statusMessage.classList.remove('show');
      }, 3000);
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    new SpriteSheetEditor();
  });
</script>
</body>
</html>
